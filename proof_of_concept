pragma solidity ^0.5.0;

/**
 * Solidity solution
 * initially sourced from: https://medium.com/coinmonks/create-a-sports-betting-dapp-on-the-ethereum-blockchain-part-1-1f69f908b939
 * @author Joe Murray
 */
 

contract Proof_of_Concept {
    address payable public owner;
    uint256 public minimumBet;
    uint256 public totalPlacedA;
    uint256 public totalPlacedB;
    address payable[] public bettors;
    struct Bettor {
        uint256 wager;
        uint16 outcome;
    }
    
    mapping(address => Bettor) public bettorInfo;
    
    function() external payable {}
    
    constructor() public {
        owner = msg.sender;
        minimumBet = 100000000000000; // this is in wei = 0.0001 ether - TODO: must find out typical transaction sizes in ether to determine reasonable betting amounts
        // TODO: should consider putting in a maximum too
    }
    
    function kill() public {
        if(msg.sender == owner) selfdestruct(owner);
    }
    
    function checkBettorExists(address payable bettor) public view returns(bool){
        for(uint256 i = 0; i < bettors.length; i++){
            if(bettors[i] == bettor) return true;
        }
        return false;
    }
    
    function placeBet(uint8 _outcome) public payable {
        // preliminary checks
        require(!checkBettorExists(msg.sender)); //make sure user has not already placed a bet 
        require(msg.value >= minimumBet); //make sure bet is sufficient // change these to Modifiers?  Doesn't seem to be an inherent advantage to either
        
        bettorInfo[msg.sender].wager = msg.value;
        bettorInfo[msg.sender].outcome = _outcome;
        
        bettors.push(msg.sender); // push new bettor address to the list thereof
        
        //assign bet
        _outcome == 1 ? totalPlacedA += msg.value : totalPlacedB += msg.value;
        
        emit BetPlaced(msg.sender, msg.value, _outcome); // give out confirmation
    }
    
    function distributePrizes(uint16 winner) public {
        address payable[1000] memory winners; //temporary memory array with fixed size e.g. 1000 (remember to limit number of bets to this)
        uint256 count = 0; // number of winners found
        uint256 loserBet = 0;
        uint256 winnerBet = 0;
        address addr;
        uint256 bet;
        uint256 prize;
        address payable bettorAddress;
        
        // loop through all bettors and reward the winners
        for(uint256 i = 0; i < bettors.length; i++){
            bettorAddress = bettors[i];
            
            if (bettorInfo[bettorAddress].outcome == winner){
                winners[count] = bettorAddress;
                count++;
                
            }
        }
        
        emit CountDebug(count);
        
        if (winner == 1){
            loserBet = totalPlacedB;
            winnerBet = totalPlacedA;
        } else {
            loserBet = totalPlacedA;
            winnerBet = totalPlacedB;
        }
        
        // finally, reward winners
        for(uint256 j = 0; j < count; j++){
            if (winners[j] != address(0)){ // ensure address is not empty
                addr = winners[j];
                bet = bettorInfo[addr].wager;
                // determine winnings and pay out
                prize = (bet*(10000 + (loserBet * 10000/winnerBet)))/10000;
                winners[j].transfer(prize); // try out various reward systems
                emit PayOut(addr, bet, prize);
            }
            emit ScanningForWinners("scanning...");
        }
        
        emit ContestComplete(winner, winnerBet, loserBet); // emit alert
        
        // reinitialise values
        delete bettorInfo[bettorAddress]; // delete all bettors
        bettors.length = 0; // delete bettors array
        loserBet = 0;
        winnerBet = 0;
        totalPlacedA = 0;
        totalPlacedB = 0;
        
    }
    
    function getAmountA() public view returns (uint256){
        return totalPlacedA;
    }
    
    function getAmountB() public view returns (uint256){
        return totalPlacedB;
    }
    
    /**
     * EVENTS
     */
     
     event BetPlaced(address bettor, uint wager, uint outcome);
     event ContestComplete(uint outcome, uint win_amount, uint lose_amount);
     event PayOut(address bettor, uint initial_wager, uint winnings);
     event ScanningForWinners(string msg);
     event CountDebug(uint count);
}